## 攻击条件：

已知 $e$，$n$，$dp$，$c$

## 关系公式：

$dp≡d\ mod\ (p-1)$
$\phi(n)=(p-1)*(q-1)$
$d*e≡1\ mod\ \phi(n)$
$m≡c^d\ mod\ n$

## 思路：

1.破解$m$的关键在于获取到$d$，利用gmpy2库，$d$=gmpy2.invert($e$,$\phi$(n))  

2.由 $\phi$，$dp≡d\ mod\ (p-1)$，可得到($p$-1)，进而得到$p$,$q$因为$n$已知,$n$=$p*q$

> 证明：
> $dp*e≡d*e\ mod\ (p-1)$
> 推导：$e*d=k_2(p-1)+dp*e$（$k_2$为整数）
> 由$e*d≡1\ mod\ (p-1)(q-1)$得$e*d=k_1(q-1)(p-q)+1$
> 所以：$k_1(q-1)(p-1)+1=k_2(p-1)+dp*c$
> 推导得：$(p-1)(k_1(q-1)-k_2)+1=dp*e$
> 令：$x=(k_1(q-1)-k_2)$，即$(p-1)x+1=dp*e$
> 因为$dp<(p-1)$
> 所以$e>x$
> 所以$x\in(1,e)$

3.求出$p$后即可求出$q$，进而求得$\phi(n)$，得到$d$ ，通过遍历$x$，可求出存在$p$，使得$n$ % $p$=0

## 代码：

```python
for i in range(1,e):           #在范围(1,e)之间进行遍历    
	if(dp*e-1)%i == 0:        
		if n%(((dp*e-1)//i)+1) == 0    #存在p,p整除n            
			p=((dp*e-1)//i)+1            
			q=n//(((dp*e-1)//i)+1)            
			phi=(q-1)*(p-1)            #欧拉定理            
			d=gmpy2.invert(e,phi)      #求模逆            
			m=pow(c,d,n)               #快速求幂取模运算
```
