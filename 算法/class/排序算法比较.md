## 什么是稳定性？

**定义**：排序前后两个相等的数相对位置不变，则算法稳定。

**总述**：各排序算法的稳定性：
1. 堆排序、快速排序、希尔排序、直接选择排序不是稳定的排序算法；
2. 基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。

![[Pasted image 20230103145049.png]]

### 一、冒泡排序

1. 小的元素往前调或者把大的元素往后调；
2. 比较是相邻的两个元素，那么交换也发生在这两个元素之间；
3. 很显然是稳定性排序算法。

### 二、选择排序

1. 每个位置选择当前元素最小的；
2. 在一趟选择中，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了；
3. 举个例子，序列 $5\ 8\ 5\ 2\ 9$， 我们知道第一遍选择第 $1$ 个元素 $5$ 会和 $2$ 交换，那么原序列中 $2$ 个 $5$ 的相对前后顺序就被破坏了；
4.  所以是不稳定的排序算法。

### 三、插入排序

1. 在有序的小序列的基础上，插入一个元素；
2. 想要插入的元素和已经有序的尾巴开始比较，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置；
3. 如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面；
4. 很显然相等元素的前后顺序没有改变，所以是稳定排序算法；

### 四、快速排序

1. 就是左右两个方向，左边的 $i$ 下标一直往右走，当 $a[i]\le a[index]$，其中 $index$ 是中枢元素的数组下标，一般取为数组第 $0$ 个元素。而右边的 $j$ 下标一直往左走，当 $a[j]\ge a[index]$；
2. 如果 $i$ 和 $j$ 都走不动了，$i < j$，交换 $a[i]$ 和 $a[j]$，重复上面的过程，直到 $i\ge j$；
3. 交换 $a[j]$ 和 $a[index]$，完成一趟快速排序；
4. 在中枢元素和 $a[j]$ 交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 $5\ 3\ 3\ 4\ 3\ 8\ 9\ 10\ 11$， 现在中枢元素 $5$ 和 $3$（第 $5$ 个元素，下标从 $1$ 开始计）交换就会把元素 $3$ 的稳定性打乱；
5. 不稳定发生在中枢元素和 $a[j]$ 交换的时刻，是不稳定的；

### 五、归并排序

1. 把序列递归地分成两个短序列，直到当子序列的长度小于等于 $1$ 才回溯，这时候把各个有序的短序列合并成一个有序的长序列，不断合并直到原序列全部排好序；
2. 合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性；
3. 稳定排序算法。

### 六、希尔排序

1. 按照不同步长对元素进行插入排序；
2. 当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；
3. 当元素基本有序了，步长很小，插入排序对于有序的序列效率很高；
4. 所以，希尔排序的时间复杂度会比 $o(n^2)$ 好一些
5. 由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱；

### 七、堆排序

1. 是选择排序特殊的一种； 
2. 堆的结构是节点 $i$ 的孩子为 $2\cdot i$ 和 $2\cdot i+1$ 节点，大顶堆要求父节点大于等于其 $2$ 个子节点，小顶堆要求父节点小于等于其 $2$ 个子节点，是完全二叉树（**我们以 $1$ 为下标存储元素值**）；
3. 在一个长为 $n$ 的序列，堆排序的过程是从第 $\frac{n}{2}$ 开始和其子节点共 $3$ 个值选择最大（大顶堆）或者最小（小顶堆），这 $3$ 个元素之间的选择当然不会破坏稳定性。但当为 $\frac{n}{2}-1, \frac{n}{2}-2,\cdots1$ 这些个父节点选择元素时，就会破坏稳定性。有可能第 $\frac{n}{2}$ 个父节点交换把后面一个元素交换过去了，而第 $\frac{n}{2}-1$ 个父节点把后面一个相同的元素没有交换，那么这 $2$ 个相同的元素之间的稳定性就被破坏了；

### 八、基数排序

1. 按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位；
2. 有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优 先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前；
3. 用于整数；
4. 需要较多的存储空间；
5. 基于分别排序，分别收集；