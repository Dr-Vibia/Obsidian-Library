## 描述

N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学不交换位置就能排成合唱队形。 合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1, 2, …, K，他们的身高分别为T1, T2, …, TK， 则他们的身高满足T1 < T2 < … < Ti , Ti > Ti+1 > … > TK (1 <= i <= K)。 你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

### 输入描述：

输入的第一行是一个整数N（2 <= N <= 100），表示同学的总数。 第一行有n个整数，用空格分隔，第i个整数Ti（130 <= Ti <= 230）是第i位同学的身高（厘米）。

### 输出描述：

可能包括多组测试数据，对于每组数据， 输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。

## 示例1

输入：

```
8
186 186 150 200 160 130 197 220
```

输出：

```
4
```

## 思路：

> 动态规划：正反两次运用LIS
> 求出以每一个点结尾的从前往后最长递增子序列 `dp1`
> 以每一个结点结尾的从后往前最长递ans增子序列 `dp2`
> 当 `dp1+dp2` 最大时，记作 `ans` ，表示剩下的同学排成合唱队形最多的人数
> 则有 `n-ans+1` 为当前状态下最少需要出列的同学人数（因为i这个位置被重复计算了一次，故需要+1)

## 代码：

```c++
/*
LIS最长递增子序列
状态方程：
dp[i] = max{dp[i], dp[j] + 1} j <= i && A[j] < A[i]
边界：
dp[i] = 1(1 <= i <= n)
*/
#include <algorithm>
#include <iostream>
#include <cstdio>

using namespace std;
const int maxn = 300;

int main(){
    int n;
    while(~scanf("%d", &n)){
        int dp1[maxn];//左边最大升序子序列的长度
        int dp2[maxn];//右边最长降序子序列的长度
        int A[maxn];        
        for(int i = 0; i < n; i++){
            scanf("%d", &A[i]);//输入
        }

        /*从前往后寻找以i点为尾的最长递增子列*/
        for(int i = 0; i < n; i++){
            dp1[i] = 1;/*每点为尾的子列长度最小都为1*/
            for(int j = 0; j < i; j++){
                if(A[j] < A[i]){
                    dp1[i] = max(dp1[i], dp1[j] + 1);
                }
            }   
        }

        /*从后往前寻找以i点为尾的最长递增子列*/
        for(int i = n - 1; i >= 0; i--){
            dp2[i] = 1;/*每点为尾的子列长度最小都为1*/
            for(int j = n - 1; j > i; j--){
                if(A[j] < A[i]){
                    dp2[i] = max(dp2[i], dp2[j] + 1);
                }
            }
        }

        int ans = 1;
        /*寻找点i两个子列和的最大值*/
        for(int i = 0; i < n; i++){
            if(dp1[i] + dp2[i] > ans){
                ans = dp1[i] + dp2[i];
            }
        }
        printf("%d\n", n - ans + 1);//重复减了自身两次，故加1

    }
    return 0;
}
```

