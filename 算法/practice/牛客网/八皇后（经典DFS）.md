## 描述

会下国际象棋的人都很清楚：皇后可以在横、竖、斜线上不限步数地吃掉其他棋子。如何将8个皇后放在棋盘上（有8 * 8个方格），使它们谁也不能被吃掉！这就是著名的八皇后问题。 对于某个满足要求的8皇后的摆放方法，定义一个皇后串a与之对应，即a=b1b2...b8，其中bi为相应摆法中第i行皇后所处的列数。已经知道8皇后问题一共有92组解（即92个不同的皇后串）。 给出一个数b，要求输出第b个串。串的比较是这样的：皇后串x置于皇后串y之前，当且仅当将x视为整数时比y小。

### 输入描述：

每组测试数据占1行，包括一个正整数b(1 <= b <= 92)

### 输出描述：

输出有n行，每行输出对应一个输入。输出应是一个正整数，是对应于b的皇后串。

## 示例1

输入：

```
1
92
```

输出：

```
15863724
84136275
```

对角线的元素有如下的性质：

- 对于一条从右上到左下的对角线，其上的棋子坐标应满足**x+y为一定值；**（比如`1,6`，`6,1`）
- 对于一条从左上到右下的对角线，其上的棋子坐标应满足**x-y为一定值**，为了避免负数的产生，代码中用x-y+n来储存数字，(比如`1,1`，`6,6`)
- 而且上述两种方案在每条对角线上得到的值各不相同，因此可以用于标识对角线是否存在元素。

```c++
#include<bits/stdc++.h>
using namespace std;

vector<string> v;	// 存储答案
int row[9],col[9],eye1[18],eye2[18],n=8,res=0,b;	// eye1、eye2为斜对角线，n代表几皇后
void dfs(int x,string s)
{
    if(x==n+1)	// 找到答案
    {
        res++;
        v.push_back(s);
        return;
    }
    for(int i=1;i<=n;i++)	//依次遍历每一行
    {
        if(!row[x]&&!col[i]&&!eye1[x+n-i]&&!eye2[x+i])	//判断是否符合条件
        {
            row[x]=col[i]=eye1[x+n-i]=eye2[x+i]=1;
            s+=i+'0';
            dfs(x+1,s);
            s.erase(s.end()-1);
            row[x]=col[i]=eye1[x+n-i]=eye2[x+i]=0;	// 回溯
        }
    }
}

int main()
{
    while(cin>>b) 
    {
        string s; 
        dfs(1, s);
        //sort(v.begin(),v.end());
        cout<<v[b-1]<<endl;
    }
}
```

