**描述**

一个整数总可以拆分为2的幂的和，例如： 7=1+2+4 7=1+2+2+2 7=1+1+1+4 7=1+1+1+2+2 7=1+1+1+1+1+2 7=1+1+1+1+1+1+1 总共有六种不同的拆分方式。 再比如：4可以拆分成：4 = 4，4 = 1 + 1 + 1 + 1，4 = 2 + 2，4=1+1+2。 用f(n)表示n的不同拆分的种数，例如f(7)=6. 要求编写程序，读入n(不超过1000000)，输出f(n)%1000000000。

**输入描述：**

每组输入包括一个整数：N(1<=N<=1000000)。

**输出描述：**

对于每组数据，输出f(n)%1000000000。

**示例1**

输入：

```
7
```

输出：

```
6
```



# 动态规划

首先说明思路：

**每一个数都可以拆成 2 的次幂的形式**，2 的次幂有（**1**，2，4，8...），其中只包括一个奇数，那就是 1。

假设给定一个数N：

1. **N 是奇数**，那么 N 拆分的时候必定有一个 1，因为 2 的次幂除了 1 都是偶数，由很多偶数不可能构成奇数。

   所以 **f(N) = f(N - 1)**

   > 举例：
   >
   > 5=（1+4）=（1+2+2）=（1+1+1+2）=（1+1+1+1+1）;一共有四种拆分形式
   >
   > 4=（4） =（2+2） =（1+1+2） = (1+1+1+1) ;一共四种拆分方式

2. **N 是偶数**，那么可以分成两种情况：

   - 2.1 **N 中拆分出 1**，N 中拆分出 1 和上边 N 是奇数的情况一样，即 f(N-1)

     > 举例：
     >
     > 4=（4）=（2+2）=（1+1+2）=（1+1+1+1）
     >
     > 3=（1+2）=（1+1+1）

   - 2.2 **N 中不拆分出 1**

     不拆分出 1，即都是偶数，偶数的性质可知，偶数都可以整除 2，假如 N 的和为 2m，那么除 2 之后变成 m，但是并不影响 f(N)。

     > 举例：
     >
     > 4=（4）=（2+2） **都不包含1**

同理，由 2.1 和 2.2 两种情况的结果相加得到完整的 4 的拆分。
也就是说 **N 为偶数**的情况就是 **f(N) = f(N-1) + f(N/2)**---------------好看一点儿就是：**f(2m) = f(2m-1) + f(m);**

```c++
#include<iostream>
using namespace std;
int dp[1000001];
int main(){
    int n;
    dp[0]=1;
    while(cin>>n){
        for(int i=1;i<=n;i++){
            if(i%2==0){
                dp[i]=(dp[i-1]+dp[i/2])%1000000000;
            }else{
                dp[i]=dp[i-1]%1000000000;
            }
        }
        cout<<dp[n]<<endl;
    }
    return 0;
}
```



# 完全背包问题

这个还没看懂……

```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 1e6 + 10, mod = 1000000000;

int n;
int f[N];

int main()
{
    cin >> n;
    f[0] = 1;
    for (int i = 1; i <= n; i *= 2)
        for (int j = i; j <= n; ++j)
                f[j] = (f[j] + f[j - i]) % mod;
    cout << f[n] << endl;
    return 0;
}
```

