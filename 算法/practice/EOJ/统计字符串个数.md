# 2846. 统计字符串个数

在 0 和 1 组成的长度为 n (1⩽n⩽20) 的字符串中，输出不包含 **“101”**子串的字符串的个数。

### 输入格式

本题有多组测试数据。每组测试数据占一行，含一个正整数 n，表示字符串的长度。`n = -1` 表示输入结束。

### 输出格式

对每组测试数据，在一行中输出表示不包含 **“101”**子串的字符串的个数。

### 样例

input

```
3
4
10
20
-1
```

output

```
7
12
351
97229
```

### 提示

长度为4，不包含**“101”**子串的字符串有12个：

0000，0001，0010，0011
0100，0110，0111，1000
1001，1100，1110，1111

#### 思路：

```
简单DP问题：很适合拿来做DP入门。
```

- 我们预设一个数组a，用来保存对应长度的子串个数。即：a[i] 为 长度为i且不含有“101”的子串个数。
- ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200408092408788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTk1Mjgw,size_16,color_FFFFFF,t_70)
- 如上图，现在考虑长度为n的子串，相当于在长度为n-1且不含有“101”的基础上前部加‘0’ + 长度为n-1且不含有“101”的子串的前部加‘1’。
- 对于第一种情况，由于加的是’0‘，我们不难发现。0对于后面n-1位不产生影响。即a[n-1]。但如果加的是’1‘，则可能在原来的基础上产生了’101‘，即目前的头部为‘101’。我们要减去这部分个数，不难发现刚好是当前头部为’10’的个数 - 当前头部为‘100’的个数。即a[n-1] - a[n-2] + a[n-3]。
- 所以最终的递归式为`a[i] = 2*a[i-1]-a[i-2]+a[i-3] (i >= 4)` 前4项需要预先填入，显然是0，2，4，7。
- EOJ上面有人Issue出：为什么不直接减去开头为‘101’的字符串？按他这种说法递推式应该是`a[i] = 2*a[i-1]-a[i-3] (i >= 4)`。显然这是不对的。确实，我们是为了减去开头为‘101’的个数。但并不是a[n-3]。因为如果直接考虑，‘101’中最后的1会对后面n-3位的子串造成影响。所以我们必须考虑前端最后为0的case。本题中考虑的是’10’和’100’。

```c++
#include <iostream>
using namespace std;
int main()
{
    int a[21] = {0, 2, 4, 7};
    for(int i = 4; i < 21; ++i)
        a[i] = 2 * a[i - 1] - a[i - 2] + a[i - 3];
    int n;
    while(cin >> n){
        if(n == -1) break;
        cout << a[n] << endl;
    }
    return 0;
}
```

