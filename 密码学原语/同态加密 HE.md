非正式地说，一组函数 $C$ 的 $C -$同态加密方案可以描述如下。给定明文 $m$ 和相应的密文 $e=Enc(m)$ ,其中 $Enc$ 是加密算法，对于一个在明文上的操作 $f\in C$ , 与相应的操作 $F$ 的密文满足： $F(e)=Enc(f(m))$ , 同样满足。在 $C -$同态加密的概念的基础上，$FHE$算法是一种对任何函数集 $C$ 都具有 $C -$同构紧凑性的加密算法。换句话说，无论对密文执行何种复杂操作，输出密文长度都是输入长度的多项式。方案的形式定义如下：

定义（完全同态加密）：一个完全同态加密算法包含四个算法：密钥生成，加密，解密和评估$（KeyGen, Enc, Dec, Eval）$。前三种算法必须具有计算效率，并且运行时间必须是安全参数的多项式，通常以密钥的位长度为特征。这四种算法描述如下：

-   $KeyGen$：算法输入安全参数生成一对公钥和私钥。记作： $KeyGen(\lambda)\to(pk,sk)$ 。
-   $Enc$: 该算法根据公钥把消息 $m$ 映射到相应的密文上。记作： $Enc(pk,m)\to c$ 。
-   $Dec$: 该算法根据私钥 $sk$ 把密文 $m$ 还原出明文 $c$ 。记作： $Dec(s,c)\to m$ 。
-   $Eval$: 该算法根据 $C$ 的函数集合，对于每一个布尔函数和对于任意一个密文 $c_1,c_2,...,c_n$ , 在公钥的条件下，$Eval$ 输出的密文 $f(m_1,m_2,...,m_n)$ 。记作：$Eval(pk,f,c_1,...,c_n)=Enc(pk,f(m_1,...,m_n))$

这种加密的模式 $\epsilon=(KeyGen,Enc,Dec,Eval)$ 被称为全同态加密模式，如果对所有布尔函数，$Eval$ 输出的密文都能正确解密，并且 $Eval(pk,f,c_1,...,c_n)$ 的长度不大于 $p(\lambda)$ .

通过 $FHE$ 算法，数据用户可以将加密数据外包给服务器，直接对这些数据执行各种操作，而不暴露这些数据包含的任何机密信息。支持的操作包括查询和修改加密数据。一旦对加密数据操作的操作已经完成，结果就返回给数据用户，数据用户使用相应的解密密钥对接收到的加密数据进行解密。在整个过程中，服务器帮助数据用户执行复杂的操作，而无需从用户的数据中获取任何信息。

**门限完全同态加密和多密钥完全同态加密。**
在 $SMPC$ 中应用时，通常采用多用户 $FHE$ 的形式。在这个场景中，多个用户加密他们自己的私有数据。所有需要的函数都是基于这些加密数据计算的。最后，用户对结果进行解密，得到相应的明文。

多用户同态加密主要有两种类型：门限$FHE$和多密钥$FHE$。在前者中，密钥生成过程是一个交互式$SMPC$协议，其中多个用户共同协商一个公钥并获取相应私钥的秘密份额。然后，所有用户都使用公共公钥对其私有数据进行加密并将其发送到服务器，其中，该服务器具有强大的计算能力。此服务器对收到的密文执行任意函数计算。最后，用户交互地应用解密协议来获得计算结果的明文。

**门限全同态加密和多密钥全同态加密区别：**
在前一种情况下，每个用户都有一个公私钥对。用户使用自己的公钥，而不是使用公共公钥来加密他们的私有数据。这样，每个用户都可以使用自己的公钥加密希望外包的个人数据，然后将其存储在外部服务器上。当用户请求服务器计算特定函数时，服务器使用存储的加密数据在本地执行计算，而不需要任何用户交互。在计算完成之后，用户交互地应用解密协议来恢复计算结果的明文。